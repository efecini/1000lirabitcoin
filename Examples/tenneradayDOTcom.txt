## Database table

CREATE TABLE `purchases` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `purchase_date` date NOT NULL,
  `eur_amount` decimal(8,2) NOT NULL,
  `btc_price` decimal(16,2) NOT NULL,
  `btc_amount` decimal(16,8) NOT NULL,
  `btc_total` decimal(16,8) NOT NULL,
  `bought_dip` tinyint(1) NOT NULL DEFAULT '0',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_purchase_date` (`purchase_date`)
) ENGINE=InnoDB AUTO_INCREMENT=159 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


## Laravel cron job runs every 24 hours
<?php

namespace App\Console\Commands;

use Carbon\Carbon;
use App\Models\Purchase;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;

class PurchaseBitcoin extends Command
{
    protected $signature = 'bitcoin:purchase';

    protected $description = 'Purchase €10 worth of Bitcoin daily at 6am';

    public function handle(): void
    {
        // Define the purchase amount in EUR
        $eurAmount = 10;
        $purchaseAmount = 9.90;

        // Fetch the current BTC price in EUR from CoinGecko
        $response = Http::get('https://api.kraken.com/0/public/Ticker', [
            'pair' => 'XXBTZEUR'
        ]);

        if ($response->successful()) {
            $ticker = $response->json();

            $btcPrice = $ticker['result']['XXBTZEUR']['a'][0];

            $btcAmount = $purchaseAmount / $btcPrice;

            $previousPurchase = Purchase::orderBy('purchase_date', 'desc')->first();

            $btcTotal = $previousPurchase->btc_total + $btcAmount;

            // Save the purchase record
            Purchase::create([
                'purchase_date' => Carbon::today(),
                'eur_amount'    => $eurAmount,
                'btc_price'     => $btcPrice,
                'btc_amount'    => $btcAmount,
                'btc_total'     => $btcTotal,
            ]);

            $this->info("Purchased €{$eurAmount} of BTC at a price of €{$btcPrice} per BTC.");
        } else {
            $this->error('Failed to retrieve Bitcoin price.');
        }
    }
}


## Frontend chart.js (uses vue3)

<template>
    <div class="p-4">
        <div class="flex justify-evenly mb-6 mx-auto w-2/5">
            <div class="bg-gray-100 p-4 rounded shadow">
                <p><strong>Total days stacking:</strong> {{ totalDaysStacking }}</p>
                <p><strong>Total euro spent:</strong> {{ formattedTotalEuroSpent }}</p>
                <p><strong>Euro per day:</strong> {{ formattedEuroPerDay }}</p>
            </div>
            <div class="bg-gray-100 p-4 rounded shadow">
                <p><strong>Total bitcoin acquired:</strong> {{ totalBitcoinAcquired.toFixed(8) }}</p>
                <p><strong>Total euro value today:</strong> {{ formattedTotalEuroValueToday }}</p>
                <p><strong>BTC per day:</strong> {{ btcPerDay }}</p>
            </div>
        </div>

        <p class="text-center mb-4">
            <strong>Last recorded bitcoin price:</strong>
            <span class="text-green-900 font-bold">&nbsp; {{ formattedBitcoinPrice }}</span>
        </p>

        <p class="text-center">
            Current status:
                <span
                    :class="getCurrentStatusClass"
                >{{ getCurrentStatus }}</span>
        </p>

        <p class="text-center mb-4">
            <span v-if="getCurrentStatus.includes('Loss')">
                Price down = I get more bitcoin per €!
            </span>
        </p>

        <router-link
            to="/purchases"
            class="text-center block underline mb-4"
        >View all purchases</router-link>

        <!-- Chart Section -->
        <canvas id="bitcoinChart"></canvas>
    </div>
</template>

<script setup>
import {ref, onMounted, computed } from 'vue';
import axios from 'axios';
import Chart from 'chart.js/auto';

const totalDaysStacking = ref(0);
const totalEuroSpent = ref(0);
const totalBitcoinAcquired = ref(0);
const totalEuroValueToday = ref(0);
const bitcoinPrice = ref(0);
const chartInstance = ref(null);

const formattedBitcoinPrice = computed(() =>
    bitcoinPrice.value.toLocaleString('en-IE', { style: 'currency', currency: 'EUR' })
);

const formattedTotalEuroSpent = computed(() =>
    totalEuroSpent.value.toLocaleString('en-IE', {
        style: 'currency',
        currency: 'EUR',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    })
);

const formattedTotalEuroValueToday = computed(() =>
    totalEuroValueToday.value.toLocaleString('en-IE', { style: 'currency', currency: 'EUR' })
);

const getCurrentStatus = computed(() => {
    // Absolute € difference
    const diff = (totalEuroValueToday.value - totalEuroSpent.value)
        .toLocaleString('en-IE', { style: 'currency', currency: 'EUR' });

    const pct = `${percentChange.value > 0 ? '+' : ''}${percentChange.value.toFixed(2)} %`;

    if (totalEuroValueToday.value > totalEuroSpent.value) {
        return `Profit ${diff} (${pct})`;
    } else if (totalEuroValueToday.value < totalEuroSpent.value) {
        return `Loss ${diff.replace('-', '')} (${pct})`;
    }

    return 'Break-even (0 %)';
});

const getCurrentStatusClass = computed(() => {
    if (totalEuroValueToday.value > totalEuroSpent.value) {
        return 'text-green-600 mb-4'
    } else if (totalEuroValueToday.value < totalEuroSpent.value) {
        return 'text-red-600'
    } else {
        // for break-even
        return 'text-gray-600 mb-4'
    }
});

const percentChange = computed(() => {
    // Avoid “divide-by-zero” the very first time the component mounts
    if (totalEuroSpent.value === 0) return 0;

    const diff = totalEuroValueToday.value - totalEuroSpent.value;
    return (diff / totalEuroSpent.value) * 100;
});

const euroPerDay = computed(() => {
    if (totalDaysStacking.value === 0) return 0;
    return totalEuroSpent.value / totalDaysStacking.value;
});

const btcPerDay = computed(() => {
    if (totalDaysStacking.value === 0) return 0;
    return (totalBitcoinAcquired.value / totalDaysStacking.value).toFixed(8);
});

/* Optional formatted versions */
const formattedEuroPerDay = computed(() =>
    euroPerDay.value.toLocaleString('en-IE', {
        style: 'currency',
        currency: 'EUR',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
    })
);

onMounted(async () => {
    try {
        const response = await axios.get('/api/purchases');

        const purchases = response.data.purchases;
        bitcoinPrice.value = response.data.btcPrice;

        if (!bitcoinPrice) {
            bitcoinPrice.value = purchases[purchases.length - 1].btc_price;
        }

        // 1) Prepare arrays
        const labels = [];
        const btcTotalStack = [];
        const stackInFiat = [];
        const todaysStackInFiat = [];
        const fiatSpentCumulative = [];
        let totalFiatSpent = 0;

        // Populate arrays for each date
        purchases.forEach(p => {
            labels.push(p.purchase_date);

            const btc   = parseFloat(p.btc_total)  || 0;
            const fiat  = parseFloat(p.eur_amount) || 0;

            // Keep track of total BTC so far
            btcTotalStack.push(btc);

            // Increase cumulative fiat spent
            totalFiatSpent += fiat;
            fiatSpentCumulative.push(totalFiatSpent);

            // Value of the entire BTC stack in fiat at the time of purchase
            const dayPrice = parseFloat(p.btc_price) || 0;
            stackInFiat.push(btc * dayPrice);

            // todo - Value of the entire BTC stack in fiat at the most recent purchase price
            // todaysStackInFiat.push(btc * bitcoinPrice.value);

            // todo - show price of bitcoin over time
        });

        // 2) Compute the summary stats
        if (purchases.length > 0) {
            // -- (A) Total days stacking
            totalDaysStacking.value = purchases.length;

            // -- (B) Total euro spent (last entry in fiatSpentCumulative)
            totalEuroSpent.value = fiatSpentCumulative[fiatSpentCumulative.length - 1];

            // -- (C) Total bitcoin acquired
            totalBitcoinAcquired.value = btcTotalStack[btcTotalStack.length - 1];

            // -- (D) Total euro value today
            totalEuroValueToday.value = stackInFiat[stackInFiat.length - 1];
        }

        // 3) Build the chart data
        const data = {
            labels,
            datasets: [
                {
                    // BTC total stack
                    label: 'BTC total stack',
                    data: btcTotalStack,
                    type: 'line',
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255, 165, 0, 0.1)',
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'yBTC',
                },
                {
                    label: 'Total BTC in Euro',
                    data: stackInFiat,
                    type: 'line',
                    borderColor: 'green',
                    backgroundColor: 'rgba(0,128,0,0.2)',
                    fill: true,
                    tension: 0.1,
                    yAxisID: 'yEUR',
                },
                {
                    label: 'Cumulative Euro spent',
                    data: fiatSpentCumulative,
                    type: 'line',
                    borderColor: 'black',
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'yEUR',
                },
            ],
        };

        // 4) Chart configuration (mixed chart, no top-level `type`)
        const config = {
            data,
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                const label = ctx.dataset.label || '';
                                const value = ctx.parsed.y;
                                if (ctx.dataset.yAxisID === 'yEUR') {
                                    return `${label}: ` + value.toLocaleString('en-US', {
                                        style: 'currency',
                                        currency: 'EUR',
                                    });
                                }
                                return `${label}: ${value.toFixed(4)} BTC`;
                            },
                        },
                    },
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Date' },
                    },
                    yBTC: {
                        type: 'linear',
                        position: 'left',
                        title: {
                            display: true,
                            text: 'BTC',
                        },
                        min: 0.0001,
                    },
                    yEUR: {
                        type: 'linear',
                        position: 'right',
                        grid: { drawOnChartArea: false },
                        title: {
                            display: true,
                            text: 'EUR',
                        },
                        ticks: {
                            callback: value => value.toLocaleString('en-US', {
                                style: 'currency',
                                currency: 'EUR',
                            }),
                        },
                    },
                },
            },
        };

        // 5) Render the chart
        const ctx = document.getElementById('bitcoinChart').getContext('2d');
        chartInstance.value = new Chart(ctx, config);
    } catch (error) {
        console.error('Error fetching purchase data:', error);
    }
});
</script>

<style scoped>
    canvas {
        max-width: 100%;
    }
</style>



## Purchases table (vue 3)

<template>
    <div class="mt-6 mx-10">

        <div class="flex flex-col pl-10">
            <div class="flex mb-4">
                <p class="text-xl font-semibold mr-10 flex-[0.5]">Purchase History</p>

                <div class="mb-4 flex-1">
                    <p>Minimum bitcoin acquired: {{ stats.min.toFixed(8) }}</p>
                    <p>Maximum bitcoin acquired: {{ stats.max.toFixed(8) }}</p>
                    <p>Average bitcoin acquired: {{ stats.average.toFixed(8) }}</p>
                </div>

                <p>BTC Price: {{ formatEurValue(bitcoinPrice) }}</p>
            </div>
            <router-link to="/" class="underline mb-4">Go back</router-link>
        </div>

        <p v-if="loading">Loading...</p>

        <div v-else>
            <table class="min-w-full border border-gray-300 mb-20">
                <thead class="sticky top-0 shadow  bg-gray-50">
                    <tr>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">Date</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">EUR Amount</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">BTC Price</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">BTC Purchased</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">That € in BTC now</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">BTC Total</th>
                        <th class="py-2 px-4 border-b border-gray-300 text-left">Running Profit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr
                        v-for="(purchase, index) in purchases"
                        :key="purchase.id"
                        class="hover:bg-gray-100"
                    >
                        <td class="py-2 px-4 border-b border-gray-200">{{ purchase.purchase_date }}</td>
                        <td class="py-2 px-4 border-b border-gray-200">€{{ Number(purchase.eur_amount).toFixed(0) }}</td>
                        <td class="py-2 px-4 border-b border-gray-200">{{ formatEurValue(purchase.btc_price) }}</td>
                        <td class="py-2 px-4 border-b border-gray-200">{{ purchase.btc_amount }}</td>
                        <td class="py-2 px-4 border-b border-gray-200">
                            €{{ (purchase.btc_amount * bitcoinPrice).toFixed(2) }}
                            <span
                                :class="calculateChange(index) >= 0
                                ? 'text-green-500 ml-2 font-bold'
                                : 'text-red-500 ml-2 font-bold'"
                            >
                                {{ formatChange(calculateChange(index)) }}
                            </span>
                        </td>
                        <td class="py-2 px-4 border-b border-gray-200">{{ purchase.btc_total }}</td>
                        <td class="py-2 px-4 border-b border-gray-200">{{ formatEurValue(calculateRunningProfit(index)) }}</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</template>

<script setup>
import {ref, onMounted, computed} from 'vue'
import axios from 'axios'

// Reactive variable to store the purchases
const purchases = ref([])
const loading = ref(true);
const bitcoinPrice = ref(0);

function formatEurValue(eurValue) {
    return parseInt(eurValue).toLocaleString('en-IE', {
        style: 'currency',
        currency: 'EUR',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
        useGrouping: true,
    });
}

function calculateRunningProfit(rowIndex) {
    // Cumulative EUR invested up to and including this row
    const cumulativeEUR = purchases.value
        .slice(0, rowIndex + 1)
        .reduce((sum, curr) => sum + parseFloat(curr.eur_amount), 0)

    // Use the provided cumulative BTC total from this row
    const cumulativeBTC = parseFloat(purchases.value[rowIndex].btc_total)

    // Current portfolio value based on the current BTC price
    const currentValue = cumulativeBTC * bitcoinPrice.value

    // Running profit
    return currentValue - cumulativeEUR
}

const stats = computed(() => {
    if (purchases.value.length === 0) {
        return { min: 0, max: 0, average: 0 }
    }

    const amounts = purchases.value.map(p => parseFloat(p.btc_amount));
    const min = Math.min(...amounts);
    const max = Math.max(...amounts);
    const average = amounts.reduce((sum, val) => sum + val, 0) / amounts.length;

    return { min, max, average };
})

const calculateChange = (rowIndex) => {
    const purchase = purchases.value[rowIndex];
    const currentValue = purchase.btc_amount * bitcoinPrice.value;

    return currentValue - parseFloat(purchase.eur_amount)
}

// 2) Format with sign + two decimals
const formatChange = (change) => {
    const sign = change >= 0 ? '+' : '-';
    const abs = Math.abs(change);

    return sign + abs.toLocaleString('en-IE', {
        style: 'currency',
        currency: 'EUR',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
    });
}

onMounted(async () => {
    try {
        const response = await axios.get('/api/purchases')

        purchases.value = response.data.purchases;

        bitcoinPrice.value = response.data.btcPrice;

        if (!bitcoinPrice) {
            bitcoinPrice.value = purchases[purchases.length - 1].btc_price;
        }

    } catch (error) {
        console.error('Error fetching purchases:', error)
    }

    loading.value = false
})
</script>

<style scoped>
/* You can add any additional component-specific styles here */
</style>



